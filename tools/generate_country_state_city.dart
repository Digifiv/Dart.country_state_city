import 'dart:convert';
import 'dart:io';

import 'package:code_builder/code_builder.dart';
import 'package:country_state_city/country_state_city.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as path;

const dataFilePath = 'lib/assets/countries_states_cities.json';
const outputDirectoryPath = 'lib/src/data';

final dataFile = File(dataFilePath);
final outputDirectory = Directory(outputDirectoryPath);

final allocator = Allocator();
const countryStateCityImportUrl =
    'package:country_state_city/country_state_city.dart';
const countryStateCityDataImportDirectoryUrl =
    'package:country_state_city/src/data';
const outputFilePrefix = 'gen_';

final dartFormatter = DartFormatter();

const _doNotEditNotice =
    '''This file is automatically generated. DO NOT EDIT manually.''';

Future<void> main() async {
  await outputDirectory.create(recursive: true);

  final countries = (jsonDecode(await dataFile.readAsString()) as List)
      .map<Country>((e) => Country.fromJson(e))
      .toList(growable: false);

  allocator.allocate(
    refer(
      'Country',
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      'Timezone',
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      'State',
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      'City',
      countryStateCityImportUrl,
    ),
  );
  final references = await Future.wait(
      countries.map((country) => _writeCountriesAsync(country)));
  await _writeConsolidatedCountryFileAsync(references);
}

Future<void> _writeConsolidatedCountryFileAsync(
    List<Reference> references) async {
  final countryTokens = <String>[];
  final allocator = Allocator();
  references.forEach((reference) {
    allocator.allocate(reference);
    countryTokens.add(reference.symbol!);
  });

  final countriesExp =
      literalList(countryTokens.map((countryToken) => refer(countryToken)));

  // Prepare to write file.

  final file = File(path.join(
    outputDirectory.path,
    'gen_countries.dart',
  ));
  final dartEmitter = DartEmitter(
    useNullSafetySyntax: true,
    allocator: allocator,
    orderDirectives: true,
  );

  final sb = StringBuffer();
  final result = countriesExp
      .assignConst('kCountries')
      .statement
      .accept(dartEmitter)
      .toString();

  sb.writeln('// $_doNotEditNotice');
  sb.writeln();
  sb.writeln(allocator.imports
      .map((e) => e.accept(dartEmitter).toString())
      .join('\n'));

  sb.writeln(result);

  await file.writeAsString(dartFormatter.format(sb.toString()));
}

Future<Reference> _writeCountriesAsync(Country country) async {
  final countryExp = refer('Country').constInstance(
    [],
    {
      'id': literal(country.id),
      'name': literal(country.name),
      'iso3': literal(country.iso3),
      'iso2': literal(country.iso2),
      'phoneCode': literal(country.phoneCode),
      'capital': literal(country.capital),
      'currency': literal(country.currency),
      'currencySymbol': literalString(country.currencySymbol, raw: true),
      'tld': literal(country.tld),
      'native': literal(country.native),
      'region': literal(country.region),
      'subregion': literal(country.subregion),
      'timezones': literalList(country.timezones.map(
        (timezone) => refer('Timezone').constInstance(
          [],
          {
            'zoneName': literal(timezone.zoneName),
            'gmtOffset': literal(timezone.gmtOffset),
            'gmtOffsetName': literal(timezone.gmtOffsetName),
            'abbreviation': literal(timezone.abbreviation),
            'tzName': literal(timezone.tzName),
          },
        ),
      )),
      'emoji': literal(country.emoji),
      'emojiU': literal(country.emojiU),
      'states': literalList(country.states.map(
        (state) => refer('State').constInstance(
          [],
          {
            'id': literal(state.id),
            'name': literal(state.name),
            'stateCode': literal(state.stateCode),
            'cities': literalList(state.cities.map(
              (city) => refer('City').constInstance(
                [],
                {
                  'id': literal(city.id),
                  'name': literal(city.name),
                  'latitude': literal(city.latitude),
                  'longitude': literal(city.longitude),
                },
              ),
            )),
          },
        ),
      )),
    },
  );

  // Identify the token that we will use for generated file name and constant
  // name.

  final countryToken = country.iso3.toLowerCase();

  // Generate import reference.

  final outputFileName = '$outputFilePrefix$countryToken.dart';
  final reference = refer(
    countryToken,
    path.join(countryStateCityDataImportDirectoryUrl, outputFileName),
  );

  // Prepare to write file.

  final file = File(path.join(
    outputDirectory.path,
    outputFileName,
  ));
  final dartEmitter = DartEmitter(
    useNullSafetySyntax: true,
    allocator: allocator,
    orderDirectives: true,
  );
  final sb = StringBuffer();
  final result = countryExp
      .assignConst(countryToken)
      .statement
      .accept(dartEmitter)
      .toString();

  sb.writeln('// $_doNotEditNotice');
  sb.writeln();
  sb.writeln(allocator.imports
      .map((e) => e.accept(dartEmitter).toString())
      .join('\n'));
  sb.writeln(result);

  await file.writeAsString(dartFormatter.format(sb.toString()));

  return reference;
}
